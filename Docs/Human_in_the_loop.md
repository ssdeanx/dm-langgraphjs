Human-in-the-loop

Skip to content

Our Building Ambient Agents with LangGraph course is now available on LangChain Academy!

# Human-in-the-loop¬∂

This guide uses the new interrupt function.

As of LangGraph 0.2.31, the recommended way to set breakpoints is using the interrupt function as it simplifies human-in-the-loop patterns.

If you're looking for the previous version of this conceptual guide, which relied on static breakpoints and NodeInterrupt exception, it is available here.

A human-in-the-loop (or "on-the-loop") workflow integrates human input into automated processes, allowing for decisions, validation, or corrections at key stages. This is especially useful in LLM-based applications, where the underlying model may generate occasional inaccuracies. In low-error-tolerance scenarios like compliance, decision-making, or content generation, human involvement ensures reliability by enabling review, correction, or override of model outputs.

## Use cases¬∂

Key use cases for human-in-the-loop workflows in LLM-based applications include:

1. üõ†Ô∏è Reviewing tool calls: Humans can review, edit, or approve tool calls requested by the LLM before tool execution.
2. ‚úÖ Validating LLM outputs: Humans can review, edit, or approve content generated by the LLM.
3. üí° Providing context: Enable the LLM to explicitly request human input for clarification or additional details or to support multi-turn conversations.

## interrupt¬∂

The interrupt function in LangGraph enables human-in-the-loop workflows by pausing the graph at a specific node, presenting information to a human, and resuming the graph with their input. This function is useful for tasks like approvals, edits, or collecting additional input. The interrupt function is used in conjunction with the Command object to resume the graph with a value provided by the human.

```
import { interrupt } from "@langchain/langgraph"; function humanNode(state: typeof GraphAnnotation.State) { const value = interrupt( // Any JSON serializable value to surface to the human. // For example, a question or a piece of text or a set of keys in the state { text_to_revise: state.some_text, } ); // Update the state with the human's input or route the graph based on the input return { some_text: value, }; } const graph = workflow.compile({ checkpointer, // Required for `interrupt` to work }); // Run the graph until the interrupt const threadConfig = { configurable: { thread_id: "some_id" } }; await graph.invoke(someInput, threadConfig); // Below code can run some amount of time later and/or in a different process // Human input const valueFromHuman = "..."; // Resume the graph with the human's input await graph.invoke(new Command({ resume: valueFromHuman }), threadConfig);
```

```
{ some_text: "Edited text"; }
```

## Requirements¬∂

To use interrupt in your graph, you need to:

1. Specify a checkpointer to save the graph state after each step.
2. Call interrupt() in the appropriate place. See the Design Patterns section for examples.
3. Run the graph with a thread ID until the interrupt is hit.
4. Resume execution using invoke/stream (see The Command primitive).

## Design Patterns¬∂

There are typically three different actions that you can do with a human-in-the-loop workflow:

1. Approve or Reject: Pause the graph before a critical step, such as an API call, to review and approve the action. If the action is rejected, you can prevent the graph from executing the step, and potentially take an alternative action. This pattern often involves routing the graph based on the human's input.
2. Edit Graph State: Pause the graph to review and edit the graph state. This is useful for correcting mistakes or updating the state with additional information. This pattern often involves updating the state with the human's input.
3. Get Input: Explicitly request human input at a particular step in the graph. This is useful for collecting additional information or context to inform the agent's decision-making process or for supporting multi-turn conversations.

Below we show different design patterns that can be implemented using these actions.

Note: The interrupt function propagates by throwing a special GraphInterrupt error. Therefore, you should avoid using try/catch blocks around the interrupt function - or if you do, ensure that the GraphInterrupt error is thrown again within your catch block.

### Approve or Reject¬∂

Depending on the human's approval or rejection, the graph can proceed with the action or take an alternative path.

Pause the graph before a critical step, such as an API call, to review and approve the action. If the action is rejected, you can prevent the graph from executing the step, and potentially take an alternative action.

```
import { interrupt, Command } from "@langchain/langgraph"; function humanApproval(state: typeof GraphAnnotation.State): Command { const isApproved = interrupt({ question: "Is this correct?", // Surface the output that should be // reviewed and approv }); // Update the state with the human's input or route the graph based on the input return new Command({ goto: isApproved ? "continue" : "reject", }); }
```

### Edit Graph State¬∂

Pause the graph to review and edit the graph state. This is useful for correcting mistakes or updating the state with additional information. This pattern often involves updating the state with the human's input.

```
import { interrupt, Command } from "@langchain/langgraph"; function humanEdit(state: typeof GraphAnnotation.State): Command { const updatedState = interrupt({ question: "Please edit the state.", state_to_edit: state, }); // Update the state with the human's input return new Command({ update: updatedState, }); }
```

### Get Input¬∂

Explicitly request human input at a particular step in the graph. This is useful for collecting additional information or context to inform the agent's decision-making process or for supporting multi-turn conversations.

```
import { interrupt, Command } from "@langchain/langgraph"; function humanInput(state: typeof GraphAnnotation.State): Command { const userInput = interrupt({ question: "Please provide additional input.", }); // Update the state with the human's input return new Command({ update: { user_input: userInput, }, }); }
```

## Additional Resources üìö¬∂

* Conceptual Guide: Persistence: Read the persistence guide for more context about persistence.
* How to Wait for User Input: Step-by-step instructions for implementing human-in-the-loop workflows that wait for user input.
* How to Review Tool Calls: Step-by-step instructions for implementing human-in-the-loop workflows that review tool calls.

Copyright ¬© 2025 LangChain, Inc | Consent Preferences

Made with Material for MkDocs Insiders